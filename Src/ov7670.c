/*
 * ov7670.c
 *
 *  Created on: Mar 7, 2024
 *      Author: claire
 */
#include <stdio.h>
#include <string.h>
#include "ov7670.h"
#include "main.h"
#include "helpers.h"

extern I2C_HandleTypeDef hi2c2;
extern DCMI_HandleTypeDef hdcmi;
extern DMA_HandleTypeDef hdma_dcmi;
extern uint16_t snapshot_buff[IMG_ROWS*IMG_COLS];

const uint8_t OV7670_reg[OV7670_REG_NUM][2] = {
  // Array format: {<reg address>, <reg_value> }
  {0x12, 0x80}, //this does a reset

  {REG_COM3, COM3_QQVGA}, // 0x04

  {0xB0, 0x84}, //Color mode

  // Hardware window
  {0x11, 0x04}, //PCLK settings, 15fps
  {REG_HSTART,0x16},
  {REG_HSTOP,	0x04},
  {REG_HREF, 0xa4}, //24 or a4?
  {REG_VSTART, 0x02},
  {REG_VSTOP, 0x7a},
  {REG_VREF, 0x0a},
  {REG_COM14, COM14_QQVGA}, //0x1a
  {REG_SCALING_XSC, SCALING_XSC_QQVGA}, // 0x70 0x3a
  {REG_SCALING_YSC, SCALING_YSC_QQVGA}, // 0x71 0x35
  //{REG_SCALING_YSC, 0xb5}, //This is to do a color bar test
  {REG_SCALING_DCWCTR, SCALING_DCWCTR_QQVGA}, // 0x72 0x22 //vertical and horizontal downsample by 4
  {REG_SCALING_PCLK_DIV, SCALING_PCLK_DIV_QQVGA}, //0x73 0xf2
  {REG_SCALING_PCLK_DELAY, SCALING_PCLK_DELAY_QQVGA},//0xa2 0x02

  // Matrix coefficients
  { 0x4f, 0x80 }, //
  { 0x50, 0x80 }, //
  { 0x51, 0x00 }, //
  { 0x52, 0x22 }, //
  { 0x53, 0x5e }, //
  { 0x54, 0x80 }, //
  { 0x58, 0x9e },

  // Gamma curve values
  { 0x7a, 0x20 }, //
  { 0x7b, 0x10 }, //
  { 0x7c, 0x1e }, //
  { 0x7d, 0x35 }, //
  { 0x7e, 0x5a }, //
  { 0x7f, 0x69 }, //
  { 0x80, 0x76 }, //
  { 0x81, 0x80 }, //
  { 0x82, 0x88 }, //
  { 0x83, 0x8f }, //
  { 0x84, 0x96 }, //
  { 0x85, 0xa3 }, //
  { 0x86, 0xaf }, //
  { 0x87, 0xc4 }, //
  { 0x88, 0xd7 }, //
  { 0x89, 0xe8 },
  // AGC and AEC parameters
  { 0xa5, 0x05 }, //
  { 0xab, 0x07 }, //
  { 0x24, 0x95 }, //
  { 0x25, 0x33 }, //
  { 0x26, 0xe3 }, //
  { 0x9f, 0x78 }, //
  { 0xa0, 0x68 }, //
  { 0xa1, 0x03 }, //
  { 0xa6, 0xd8 }, //
  { 0xa7, 0xd8 }, //
  { 0xa8, 0xf0 }, //
  { 0xa9, 0x90 }, //
  { 0xaa, 0x94 }, //
  { 0x10, 0x00 },

  // AWB parameters
  { 0x43, 0x0a }, //
  { 0x44, 0xf0 }, //
  { 0x45, 0x34 }, //
  { 0x46, 0x58 }, //
  { 0x47, 0x28 }, //
  { 0x48, 0x3a }, //
  { 0x59, 0x88 }, //
  { 0x5a, 0x88 }, //
  { 0x5b, 0x44 }, //
  { 0x5c, 0x67 }, //
  { 0x5d, 0x49 }, //
  { 0x5e, 0x0e }, //
  { 0x6c, 0x0a }, //
  { 0x6d, 0x55 }, //
  { 0x6e, 0x11 }, //
  { 0x6f, 0x9f }, //
  { 0x6a, 0x40 }, //
  { 0x01, 0x40 }, //
  { 0x02, 0x60 }, //
  { 0x13, 0xe7 },

  // Additional parameters
  { 0x34, 0x11 }, //
  { 0x3f, 0x00 }, //
  { 0x75, 0x05 }, //
  { 0x76, 0xe1 }, //
  { 0x4c, 0x00 }, //
  { 0x77, 0x01 }, //
  { 0xb8, 0x0a }, //
  { 0x41, 0x18 }, //
  { 0x3b, 0x12 }, //
  { 0xa4, 0x88 }, //
  { 0x96, 0x00 }, //
  { 0x97, 0x30 }, //
  { 0x98, 0x20 }, //
  { 0x99, 0x30 }, //
  { 0x9a, 0x84 }, //
  { 0x9b, 0x29 }, //
  { 0x9c, 0x03 }, //
  { 0x9d, 0x4c }, //
  { 0x9e, 0x3f }, //
  { 0x78, 0x04 }, //
  { 0x0e, 0x61 }, //
  { 0x0f, 0x4b }, //
  { 0x16, 0x02 }, //
  { 0x1e, 0x00 }, //
  { 0x21, 0x02 }, //
  { 0x22, 0x91 }, //
  { 0x29, 0x07 }, //
  { 0x33, 0x0b }, //
  { 0x35, 0x0b }, //
  { 0x37, 0x1d }, //
  { 0x38, 0x71 }, //
  { 0x39, 0x2a }, //
  { 0x3c, 0x78 }, //
  { 0x4d, 0x40 }, //
  { 0x4e, 0x20 }, //
  { 0x69, 0x00 }, //
  { 0x6b, 0x3a }, //3a/4a?
  { 0x74, 0x10 }, //
  { 0x8d, 0x4f }, //
  { 0x8e, 0x00 }, //
  { 0x8f, 0x00 }, //
  { 0x90, 0x00 }, //
  { 0x91, 0x00 }, //
  { 0x96, 0x00 }, //
  { 0x9a, 0x00 }, //
  { 0xb1, 0x0c }, //
  { 0xb2, 0x0e }, //
  { 0xb3, 0x82 }, //
  { 0x4b, 0x01 },
};

uint8_t ov7670_init(void){
  for(int i=0; i<OV7670_REG_NUM; i++){
	ov7670_write(OV7670_reg[i][0],OV7670_reg[i][1]);
	HAL_Delay(10);
  }
  return 0;
}

HAL_StatusTypeDef ov7670_write(uint8_t reg,uint8_t val){
	uint8_t data[2];
	data[0] = reg;
	data[1] = val;
	HAL_StatusTypeDef status = HAL_I2C_Master_Transmit(&hi2c2, 0x43, data, 2, 1000);
	return status;
}

void ov7670_capture(uint16_t *buff){
	uint32_t length = (IMG_ROWS*IMG_COLS*2)/4; //rows*cols* 2 bytes per pixel/4 bytes per word
	HAL_DCMI_Start_DMA(&hdcmi, DCMI_MODE_CONTINUOUS, (uint32_t)buff, length);
}
